{"version":3,"sources":["../source/phone.js"],"names":["validate","parse_plaintext_international","template","local_phone_digits","parse_digits","count_digits","format","derive_phone_number_format","format_local","format_international","populate_template","digits_in_local_phone_number_template","digits_in_international_phone_number_template","digit_index","index_in_template","plaintext_international","plaintext_local","trim_trunk_prefix","add_trunk_prefix","trunk_prefix","value","console","error","length","country","formatted","with_trunk_prefix","digits","Error","trunk_prefix_index","search","trunk_prefix_ends_at","test","left_out_template","slice","opening_braces","count_occurences","closing_braces","dangling_braces","replace","phone_country","number","trim","populated","brace_open","symbol_index","symbol","indexOf","_template","regular_expression","match","caret_position","phone_template","digit_index_so_far","i","plaintext","string","count","character"],"mappings":"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CAAtB,EAAyBvB,sCAAsCL,MAAtC,EAA8CU,eAA9C,EAA+DU,iBAA/D,CAAzB,CAAP;AACA;;AAED;AACO,SAAStB,YAAT,CAAsBgB,KAAtB,EACP;AACC;AACA,KAAI,CAACA,KAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED;AACA,QAAOA,MAAMmB,OAAN,CAAc,SAAd,EAAyB,EAAzB,CAAP;AACA;;AAED;AACO,SAASlC,YAAT,CAAsBe,KAAtB,EACP;AACE,QAAOhB,aAAagB,KAAb,EAAoBG,MAA3B;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASjB,MAAT,CAAgBc,KAAhB,EAAuBd,MAAvB,EACP;AACC,KAAI,CAACc,KAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED;AACA;AACA,KAAId,MAAJ,EACA;AACC,SAAOE,aAAaY,KAAb,EAAoBd,MAApB,CAAP;AACA;;AAED;AACA;AACA;;AAEA;AACA;AACAA,UAASC,2BAA2Ba,KAA3B,CAAT;;AAEA;AACA,KAAId,MAAJ,EACA;AACC;AACA,SAAOG,qBAAqBW,KAArB,EAA4Bd,MAA5B,CAAP;AACA;;AAED;AACA;AACA;AACA,QAAOc,KAAP;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASb,0BAAT,CAAoCa,KAApC,EACP;AACC;AACA,KAAMoB,gBAAgB,uBAAepB,KAAf,CAAtB;;AAEA;AACA;AACA,KAAI,CAACoB,aAAL,EACA;AACCnB,UAAQC,KAAR,uHAAkIF,KAAlI;AACA;AACA;;AAED;AACA,KAAMd,SAAS,kBAAQkC,aAAR,CAAf;;AAEA;AACA;AACA,KAAI,CAAClC,MAAL,EACA;AACCe,UAAQC,KAAR,kDAA6DkB,aAA7D;AACA;AACA;;AAED,QAAOlC,MAAP;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASE,YAAT,CAAsBY,KAAtB,EAA6Bd,MAA7B,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","file":"phone.js","sourcesContent":["import formats from './formats'\nimport detect_country, { country_from_locale } from './country'\n\n// Validates an international plaintext phone number (e.g. \"+79991234567\")\nexport function validate(plaintext_international, format)\n{\n\t// Sanity check\n\tif (!plaintext_international)\n\t{\n\t\treturn false\n\t}\n\t\n\t// If format is not specified, then try to autodetect it.\n\tif (!format)\n\t{\n\t\t// Derive phone number format from the\n\t\t// phone number itself (if it's international)\n\t\tformat = derive_phone_number_format(value)\n\t}\n\n\t// If not phone number format is present,\n\t// then assume the phone number is invalid.\n\tif (!format)\n\t{\n\t\tconsole.error(`No \"format\" specified for phone number validation. Assuming the phone number is invalid.`)\n\t\treturn false\n\t}\n\n\treturn plaintext_international.length ===\n\t\t'+'.length +\n\t\tformat.country.length +\n\t\tdigits_in_international_phone_number_template(format, plaintext_international)\n}\n\n// Reduces a formatted phone number to an \n// international plaintext one (with country code).\n//\n// E.g. \"8 (999) 123-45-67\" -> \"+79991234567\"\n//       \"+7 999 123 45 67\" -> \"+79991234567\"\n//           \"07700 900756\" -> \"+447700900756\"\n//\n// This function is used in <input/> to parse text into `value`\n//\nexport function parse_plaintext_international(formatted, format, with_trunk_prefix)\n{\n\t// The input digits\n\tlet digits = parse_digits(formatted)\n\n\tif (!digits)\n\t{\n\t\treturn ''\n\t}\n\n\t// If the input wass already international,\n\t// just return the digits with the '+' sign.\n\tif (formatted[0] === '+')\n\t{\n\t\treturn `+${digits}`\n\t}\n\n\t// Otherwise it's a local phone number\n\n\t// Trim excessive phone number digits\n\t// (this is used in <input/>)\n\tdigits = local_phone_digits(digits, format, with_trunk_prefix)\n\n\t// Convert local plaintext to international plaintext\n\treturn plaintext_international(digits, format, with_trunk_prefix)\n}\n\n// Returns phone number template based on the phone format.\n//\n// E.g. \"RU\" -> \"8 (AAA) BBB-BB-BB\"\n//\nexport function template(format, value, with_trunk_prefix)\n{\n\tif (with_trunk_prefix === false)\n\t{\n\t\tvalue = add_trunk_prefix(value, format)\n\t}\n\n\t// Will hold the return value\n\tlet template\n\n\t// Simple phone number formatting\n\tif (typeof format.template === 'string')\n\t{\n\t\ttemplate = format.template\n\t}\n\t// Custom phone number formatting\n\telse if (typeof format.template === 'function')\n\t{\n\t\ttemplate = format.template(value)\n\t}\n\n\t// Sanity check\n\t// (e.g. when `template` function didn't return a template)\n\tif (!template)\n\t{\n\t\tthrow new Error(`Phone number template is not defined for phone number \"${value}\" for country code \"${format.country}\"`)\n\t}\n\n\t// Optionally remove trunk prefix part from the template\n\t// (and dangling braces too)\n\tif (with_trunk_prefix === false)\n\t{\n\t\t// Where trunk prefix begins\n\t\tconst trunk_prefix_index = template.search(/[0-9]/)\n\n\t\t// Find where trunk prefix ends\n\t\tlet trunk_prefix_ends_at = trunk_prefix_index\n\t\twhile (/[0-9\\-\\s]/.test(template[trunk_prefix_ends_at + 1]))\n\t\t{\n\t\t\ttrunk_prefix_ends_at++\n\t\t}\n\n\t\t// Split template into two parts:\n\t\t// one with trunk prefix and the other without trunk prefix.\n\t\tconst left_out_template = template.slice(0, trunk_prefix_ends_at)\n\t\ttemplate = template.slice(trunk_prefix_ends_at + 1)\n\t\t\n\t\t// Fix dangling braces (e.g. for UK numbers: \"(0AA) BBBB BBBB\")\n\t\t\n\t\tconst opening_braces = count_occurences('(', left_out_template)\n\t\tconst closing_braces = count_occurences(')', left_out_template)\n\n\t\tlet dangling_braces = opening_braces - closing_braces\n\t\twhile (dangling_braces > 0)\n\t\t{\n\t\t\ttemplate = template.replace(')', '')\n\t\t\tdangling_braces--\n\t\t}\n\t}\n\n\treturn template\n}\n\n// Converts a local formatted phone number to just digits\n// while also trimming excessive digits in the end.\n//\n// E.g. \"8 (999) 123-45-67\" -> \"89991234567\"\n//\nexport function local_phone_digits(value, format, with_trunk_prefix)\n{\n\tconst plaintext_local = parse_digits(value)\n\treturn plaintext_local.slice(0, digits_in_local_phone_number_template(format, plaintext_local, with_trunk_prefix))\n}\n\n// Retains only digits in a string\nexport function parse_digits(value)\n{\n\t// Sanity check\n\tif (!value)\n\t{\n\t\treturn ''\n\t}\n\n\t// Replace all non-digits with emptiness\n\treturn value.replace(/[^0-9]/g, '')\n}\n\n// Counts digits in a string\nexport function count_digits(value)\n{\n  return parse_digits(value).length\n}\n\n// Formats a plaintext phone number\n// (either local or international):\n// if `format` is passed, then formats\n// `value` as a local phone number,\n// otherwise formats `value` as an\n// international phone number.\n//\n// `format` can be a phone number format structure,\n// or an ISO 3166-1 country code, or a locale.\n//\n// If `format` is not specified then\n// the appropriate international number format\n// will be derived from the phone number itself\n// (only if it's plaintext international)\n//\n// E.g.: (\"+79991234567\")        -> \"+7 999 123 45 67\"\n//       (\"9991234567\", 'ru-RU') -> \"(999) 123-45-67\"\n//\n//       (\"+447700900756\")     -> \"+44 7700 900756\"\n//       (\"07700900756\", 'GB') -> \"07700 900756\"\n//\nexport function format(value, format)\n{\n\tif (!value)\n\t{\n\t\treturn ''\n\t}\n\n\t// If format is specified, then format\n\t// the phone number as a local one.\n\tif (format)\n\t{\n\t\treturn format_local(value, format)\n\t}\n\n\t// Otherwise, if format is not specified,\n\t// then try to autodetect it\n\t// (only if the phone is plaintext international)\n\n\t// Derive phone number format from the\n\t// phone number itself (if it's international)\n\tformat = derive_phone_number_format(value)\n\n\t// If phone number format was successfully derived\n\tif (format)\n\t{\n\t\t// Format the phone number as an international one\n\t\treturn format_international(value, format)\n\t}\n\n\t// No suitable phone format found,\n\t// so it doesn't know how to format the phone number.\n\t// At least it won't crash and will output something.\n\treturn value\n}\n\n// Derives phone number format from\n// the plaintext phone number itself\n// (assuming it's an international one)\n//\n// E.g.  \"+78005553535\" -> \"RU\"\n//      \"+447700900431\" -> \"UK\"\n//\nexport function derive_phone_number_format(value)\n{\n\t// Derive country from the phone number (if it's international)\n\tconst phone_country = detect_country(value)\n\n\t// If no original phone country could be detected,\n\t// then it won't know how to format the phone number.\n\tif (!phone_country)\n\t{\n\t\tconsole.error(`No phone number format was passed and no country could be derived from the international plaintext phone number \"${value}\". Create an issue in the project repo on GitHub: https://github.com/halt-hammerzeit/react-phone-number-input/issues`)\n\t\treturn\n\t}\n\n\t// Phone format for the phone number\n\tconst format = formats[phone_country]\n\n\t// If there's no predefined phone number format for this country,\n\t// then it won't know how to format the phone number.\n\tif (!format)\n\t{\n\t\tconsole.error(`Phone number format is missing for country \"${phone_country}\". Create a Pull Request with the phone format for this country in the project repo on GitHub: https://github.com/halt-hammerzeit/react-phone-number-input/issues`)\n\t\treturn\n\t}\n\n\treturn format\n}\n\n// Formats a plaintext phone number\n// (either local or international)\n// as a local phone number.\n//\n// The `format` attribute can be either a phone formatter,\n// or an ISO 3166-1 country code, or a locale.\n//\n// E.g.: \"+79991234567\" -> \"(999) 123-45-67\"\n// E.g.:   \"9991234567\" -> \"(999) 123-45-67\"\n//\n// This function is used in <input/> to format `value` into text\n//\nexport function format_local(value, format, with_trunk_prefix)\n{\n\t// Find a phone number format corresponding\n\t// to this ISO 3166-1 country code or locale.\n\tif (typeof format === 'string')\n\t{\n\t\tformat = formats[country_from_locale(format) || format]\n\t}\n\n\tif (!format)\n\t{\n\t\tthrow new Error(`Phone number format was not specified for formatting value \"${value}\"`)\n\t}\n\n\t// Sanity check\n\tif (!value)\n\t{\n\t\treturn ''\n\t}\n\n\t// Convert plaintext international into plaintext local (if needed)\n\t// (don't prepend trunk prefix)\n\tvalue = plaintext_local(value, format, with_trunk_prefix)\n\n\tif (!value)\n\t{\n\t\treturn ''\n\t}\n\n\t// Populate phone template (without trunk prefix) with digits\n\treturn populate_template(template(format, value, with_trunk_prefix), value)\n}\n\n// Formats an plaintext phone number\n// (either local or international)\n// as an international phone number.\n//\n// E.g.: \"+79991234567\" -> \"+7 999 123 45 67\"\n// E.g.:   \"9991234567\" -> \"+7 999 123 45 67\"\nexport function format_international(value, format)\n{\n\tlet number = format_local(value, format)\n\t\t// Remove brackets\n\t\t.replace(/[\\(\\)]/g, '')\n\t\t// Replace dashes with spaces\n\t\t.replace(/\\-/g, ' ')\n\t\t.trim()\n\n\t// Trim trunk prefix\n\tnumber = trim_trunk_prefix(number, format)\n\n\treturn `+${format.country} ${number}`\n}\n\n// Populates local phone template with `digits`\n// (which are plaintext local phone number).\n//\n// E.g. (\"(AAA) BBB-BB-BB\", \"1234567890\") -> \"(123) 456-78-90\"\n//              (\"8 (xxx) xxx-xx-xx\", \"\") -> \"\"\n//             (\"8 (xxx) xxx-xx-xx\", \"8\") -> \"8\"\n//            (\"8 (xxx) xxx-xx-xx\", \"81\") -> \"8 (1  )\"\n//           (\"8 (xxx) xxx-xx-xx\", \"812\") -> \"8 (12 )\"\n//          (\"8 (xxx) xxx-xx-xx\", \"8123\") -> \"8 (123)\"\n//   (\"8 (xxx) xxx-xx-xx\", \"81234567890\") -> \"8 (123) 456-78-90\"\n//\nexport function populate_template(template, digits)\n{\n\tif (!digits)\n\t{\n\t\treturn ''\n\t}\n\n\tlet populated = ''\n\tlet digit_index = 0\n\tlet brace_open = false\n\tlet symbol_index = 0\n\tlet symbol\n\n\t// Replace letters with digits in a cycle\n\twhile (symbol_index < template.length)\n\t{\n\t\tsymbol = template[symbol_index]\n\n\t\tif ((symbol >= 'A' && symbol <= 'z')\n\t\t\t|| (symbol >= '0' && symbol <= '9'))\n\t\t{\n\t\t\tsymbol = digits[digit_index]\n\t\t\tdigit_index++\n\t\t}\n\t\telse if (symbol === '(')\n\t\t{\n\t\t\tbrace_open = true\n\t\t}\n\n\t\tpopulated += symbol\n\t\tsymbol_index++\n\n\t\tif (digit_index === digits.length)\n\t\t{\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If a parenthesis was opened, then close it,\n\t// and trim everything else.\n\tif (brace_open)\n\t{\n\t\treturn populated + template.slice(symbol_index, template.indexOf(')') + 1).replace(/[0-9A-z]/g, ' ')\n\t}\n\n\t// Otherwise just trim everything after the last populated letter\n\treturn populated\n}\n\n// Returns digit count in a local phone number format template\n// (count trunk prefix digits in)\n//\n// E.g. \"8 (AAA) BBB-BB-BB\" -> 11\n//\nexport function digits_in_local_phone_number_template(format, plaintext_local, with_trunk_prefix)\n{\n\tconst _template = template(format, plaintext_local)\n\tconst regular_expression = with_trunk_prefix === false ? /[A-z]/g : /[0-9A-z]/g\n\treturn (_template.match(regular_expression) || []).length\n}\n\n// Returns digit count in an international phone number format template\n// (ignoring trunk prefix digits)\n//\n// E.g. \"8 (AAA) BBB-BB-BB\" -> 10\n//\nexport function digits_in_international_phone_number_template(format, plaintext_international)\n{\n\tconst _template = template(format, plaintext_local(plaintext_international, format))\n\treturn (_template.match(/[A-z]/g) || []).length\n}\n\n// Finds digit index in value at caret position\n// (if there's no digit at caret position then \n//  returns the index of the closest next digit)\n//\n// E.g. (\"1-123-456-7890\", 0) -> 0 (first digit)\n//        ^\n//      (\"1-123-456-7890\", 1) -> 1 (second digit)\n//         ^\n//      (\"1-123-456-7890\", 2) -> 1 (second digit)\n//          ^\n//      (\"1-123-456-7890\", 3) -> 2 (third digit)\n//           ^\n//      (\"1-123-456-7890\", 4) -> 3 (fourth digit)\n//            ^\n//\nexport function digit_index(value, caret_position)\n{\n\treturn count_digits(value.slice(0, caret_position))\n}\n\n// Finds index of digit symbol in template.\n//\n// E.g. (0, \"(AAA) BBB-BB-BB\") -> 1 (first digit is at index 1 in template string)\n//            ^\n//      (1, \"(AAA) BBB-BB-BB\") -> 2 (second digit is at index 2 in template string)\n//             ^\n//      (2, \"(AAA) BBB-BB-BB\") -> 3 (third digit is at index 3 in template string)\n//              ^\n//      (3, \"(AAA) BBB-BB-BB\") -> 6 (fourth digit is at index 6 in template string)\n//                 ^\n//      (4, \"(AAA) BBB-BB-BB\") -> 7 (fifth digit is at index 7 in template string)\n//                  ^\n//\nexport function index_in_template(digit_index, format, digits, with_trunk_prefix)\n{\n\tconst phone_template = template(format, digits, with_trunk_prefix)\n\n\tlet digit_index_so_far = -1\n\tlet i = 0\n\twhile (i <= phone_template.length)\n\t{\n\t\tif ((phone_template[i] >= 'A' && phone_template[i] <= 'z')\n\t\t\t|| (with_trunk_prefix !== false && (phone_template[i] >= '0' && phone_template[i] <= '9')))\n\t\t{\n\t\t\tdigit_index_so_far++\n\t\t}\n\n\t\tif (digit_index_so_far === digit_index)\n\t\t{\n\t\t\treturn i\n\t\t}\n\n\t\ti++\n\t}\n}\n\n// Converts a plaintext (local or international)\n// phone number to an international one.\n//\n// E.g. \"+78005553535\" -> \"+78005553535\"\n//        \"8005553535\" -> \"+78005553535\"\n//       \"07700900756\" -> \"+447700900756\"\nexport function plaintext_international(plaintext, format, with_trunk_prefix)\n{\n\tif (!plaintext)\n\t{\n\t\treturn ''\n\t}\n\n\t// If it's already plaintext international, then don't change it\n\tif (plaintext[0] === '+')\n\t{\n\t\treturn plaintext\n\t}\n\n\t// Otherwise it's a local plaintext phone number\n\n\t// Trim trunk prefix from the phone number,\n\t// and add country code with a '+' sign to it.\n\n\tif (with_trunk_prefix !== false)\n\t{\n\t\tplaintext = trim_trunk_prefix(plaintext, format)\n\t}\n\n\tif (!plaintext)\n\t{\n\t\treturn ''\n\t}\n\n\treturn `+${format.country}${plaintext}`\n}\n\n// Converts a plaintext (local or international)\n// phone number to a local one.\n//\n// E.g.  \"07700900756\" -> \"07700900756\"\n//     \"+447700900756\" -> \"07700900756\"\n//\nexport function plaintext_local(plaintext, format, with_trunk_prefix)\n{\n\tif (!plaintext)\n\t{\n\t\treturn ''\n\t}\n\n\t// If it's already plaintext local, then don't change it\n\tif (plaintext[0] !== '+')\n\t{\n\t\treturn plaintext\n\t}\n\n\t// Otherwise it's plaintext international\n\t// so trim country code along with the '+' sign\n\t// and add trunk prefix\n\n\tplaintext = plaintext.slice('+'.length + format.country.length)\n\n\tif (with_trunk_prefix !== false)\n\t{\n\t\tplaintext = add_trunk_prefix(plaintext, format)\n\t}\n\n\treturn plaintext\n}\n\n// Trims trunk prefix from the phone number\n// https://en.wikipedia.org/wiki/Trunk_prefix\n//\n// E.g. \"88005553535\" -> \"8005553535\" // Russia\n//      \"07700900756\" -> \"7700900756\" // UK\n//\nexport function trim_trunk_prefix(digits, format)\n{\n\treturn digits.slice(trunk_prefix(format, digits).length)\n}\n\n// Adds trunk prefix to the phone number\n// https://en.wikipedia.org/wiki/Trunk_prefix\n//\n// E.g. \"8005553535\" -> \"88005553535\" // Russia\n//      \"7700900756\" -> \"07700900756\" // UK\n//\nexport function add_trunk_prefix(digits, format)\n{\n\treturn trunk_prefix(format, digits) + digits\n}\n\n// Extracts trunk prefix from phone number format\n// https://en.wikipedia.org/wiki/Trunk_prefix\n//\nexport function trunk_prefix(format, digits = '')\n{\n\tlet trunk_prefix = ''\n\n\tfor (let symbol of template(format, digits))\n\t{\n\t\tif (symbol >= '0' && symbol <= '9')\n\t\t{\n\t\t\ttrunk_prefix += symbol\n\t\t}\n\t\telse if (symbol >= 'A' && symbol <= 'z')\n\t\t{\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn trunk_prefix\n}\n\n// Counts all occurences of a symbol in a string\nfunction count_occurences(symbol, string)\n{\n\tlet count = 0\n\n\tfor (let character of string)\n\t{\n\t\tif (character === symbol)\n\t\t{\n\t\t\tcount++\n\t\t}\n\t}\n\n\treturn count\n}"]}